## Основы Git
**Git является распределенной системой контроля версий, предназначенной для работы с нашим кодом.** <br>Ее применение особенно важно для распределенных команд, поскольку она позволяет отслеживать изменения, происходящие с течением времени.

**Путем последовательного анализа мы можем видеть, какие файлы были изменены и каким образом.** Это очень полезно в случае, когда мы хотим понять, какие модификации были произведены в рамках конкретной задачи, так как это дает возможность вернуться к предыдущим версиям.

Допустим, у нас был работающий код, все в нем функционировало хорошо, но мы решили его улучшить, внести поправки тут и там. Хотя все может быть в порядке, такое улучшение могло испортить половину функционала и сделать работу невозможной. Что делать в такой ситуации? Без Git мы бы потратили часы на то, чтобы вспомнить, как все было изначально. Но с помощью Git мы просто откатываемся к предыдущей версии кода - и все в порядке.

**А что если два разработчика одновременно вносят изменения в код?** Без Git все выглядело бы так: они копируют код из исходного файла, делают свои изменения и приходит момент, когда оба хотят добавить свои изменения в основную папку. Что делать в такой ситуации?.. Мне даже страшно представить, сколько времени бы пришлось потратить на такую работу.Но с использованием Git такие проблемы исключены.

**Установка Git**
<br>Давайте установим Git на компьютер. Я понимаю, что у каждого может быть разная операционная система, поэтому я расскажу о установке для нескольких случаев.

**Установка для Windows**
<br>Как обычно, нужно скачать исполняемый файл (exe) и запустить его. Процесс довольно прост: нажимаем на первую ссылку в поисковике Google, устанавливаем и готово. Для работы мы будем использовать Bash-консоль, предоставляемую Git.

**Чтобы работать в Windows, необходимо запустить Git Bash. Он находится в меню *«Пуск»*.**

**Настройка репозитория Гит**<br>
У Гита есть функция настройки пользователя, от имени которого будет выполняться работа. Это важный и необходимый аспект, поскольку при создании коммита Гит использует эту информацию для заполнения поля "Автор".

**Для настройки имени пользователя и электронной почты для всех проектов необходимо выполнить следующие команды:**

*git config --global user.name "Иван Иванов"* <br>
*git config --global user.email ivan.ivanov@gmail.com*

Если требуется изменить автора для конкретного проекта (например, для личного проекта), можно убрать флаг "--global", и применить следующие команды:

*git config user.name "Иван Иванов"* <br>
*git config user.email ivan.ivanov@gmail.com*

**Какие термины и действия мы будем рассматривать?**<br>
*Гит репозиторий (git repository);<br>*
*коммит (commit);<br>*
*ветка (branch);<br>*
*слияние (merge);<br>*
*конфликты (conflicts);<br>*
*получить изменения (pull);<br>*
*отправить изменения (push);<br>*
*игнорировать файлы (.gitignore).<br>*
и так далее.

## Состояния в Гите ##

*В Гите существуют различные состояния, которые нужно понимать и запоминать:*

непрослеживаемый (**untracked**);<br>
измененный (**modified**);<br>
подготовленный (**staged**);<br>
закомиченный (**committed**).

**Как их понимать?<br>**
Это различные состояния, в которых могут находиться файлы в нашем коде. То есть, их путь в жизни обычно выглядит так:<br>
Файл, который был создан, но еще не добавлен в репозиторий, находится в состоянии untracked.
При внесении изменений в файлы, которые уже добавлены в гит репозиторий, они переходят в состояние modified.<br>
Затем, из измененных файлов мы выбираем только те, которые нужны нам (например, мы не нуждаемся в скомпилированных классах), и эти файлы с изменениями переходят в состояние staged.
Из заготовленных файлов в состоянии staged создается коммит и он сохраняется в гит репозитории. После этого staged состояние становится пустым. Но modified состояние может содержать еще некоторые изменения.

## Что такое коммит ##

**Коммит** – важное понятие в управлении контролем версий. Этот объект содержит все изменения, сделанные за определенный период. Коммиты связаны в цепочку, которая позволяет отслеживать историю изменений.

Когда создается новый коммит, он сохраняет информацию о своих предшественниках. Таким образом, каждый коммит знает, какой коммит идет перед ним в списке. Это позволяет легко отследить порядок изменений.

Коммит также содержит дополнительные метаданные, включая:
- Уникальный идентификатор, который позволяет точно найти коммит в системе;
- Имя автора коммита, указывающее на человека, который создал изменения;
- Дата создания коммита, определяющая момент внесения изменений;
- Комментарий, описывающий, какие изменения были внесены в рамках данного коммита.

*Эти особенности коммитов играют важную роль в управлении версиями кода и других проектов*, позволяя разработчикам точно отслеживать историю изменений и легко возвращаться к предыдущим версиям.

## Что такое ветка ##

**Ветка** — это указатель какого-то коммита. Так как коммит знает, какой коммит был до него, когда ветка указывает на какой-то коммит, к ней относятся и все те предыдущие.

*Исходя из этого можно сказать, что веток, указывающих на один и тот же коммит, может быть сколько угодно много.*

Работа происходит в ветках, поэтому когда создается новый коммит, ветка переносит свой указатель на более новый коммит.<br>

**Начало работы с Гитом**<br>
Можно работать только с локальным и удаленным репозиторием.

Для отработки нужных команд можно воспользоваться **только локальным репозиторием**. Он хранит всю информацию только локально в проекте в папке .git.

Если говорить об удаленном, то вся информация хранится где-то на удаленном сервере: локально хранится только копия проекта, изменения которой можно запушить (git push) в удаленный репозиторий.

**Работа с локальным репозиторием Git**

Для создания локального репозитория необходимо выполнить следующую команду:

*git init*

*Как только вы откроете консоль, на месте её расположения будет автоматически создана папка .git.*

**.git** — каталог, содержащий всю необходимую информацию о гите-репозитории. Не нужно удалять его 

Затем в этот проект добавляются файлы, что приводит их к состоянию "Untracked". Чтобы узнать текущий статус работ, введите в консоли следующую команду:

*git status*

Мы находимся в текущей **master** ветке и пока не перейдем в другую, все останется неизменным.

Данная ситуация позволяет нам видеть, какие файлы были изменены, но еще не добавлены в **staged**состояние. Чтобы добавить их в **staged** состояние, необходимо написать команду *git add*. Здесь мы можем выбрать несколько вариантов:
- **git add** -A – добавляет в *staged* состояние все файлы из текущего состояния;
- **git add** . – добавляет в *staged* состояние все файлы из текущей папки и всех ее подпапок;
- **git add** <*имя файла*> – добавляет только определенный файл. В данном случае можно использовать регулярные выражения для добавления файлов по шаблону. Например, *git add *.java* означает, что нужно добавить только файлы с расширением java.

Очевидно, что первые два варианта являются простыми, в то время как последний вариант предлагает более интересные возможности. Давайте напишем команду:

**git add .txt**

Для проверки текущего статуса репозитория мы можем использовать уже знакомую нам команду:

*git status*

Отсюда видно, что регулярное выражение отработало верно, и теперь *test_resource.txt* находится в staged состоянии.

И, наконец, последний этап (при локальном репозитории, с удаленным будет еще один ) — *закоммитить и создать новый коммит*:

*git commit -m “add your comment”*

*Продолжим исследование истории коммитов в ветке с помощью замечательной команды:*

**git log.**

Эта удивительная функция предоставит нам полный доступ ко всем коммитам, сделанным в данной ветке. Нам откроется возможность изучить детали каждого коммита, такие как автор, дата, сообщение и даже изменения, внесенные в файлы проекта. Это незаменимый инструмент для анализа и отслеживания процесса разработки, позволяющий нам точно понять, что происходило на протяжении всей истории кодовой базы.

**git log** – это тот мощный инструмент, который поможет нам оставаться на вершине программного искусства и делать наши проекты гораздо более надежными и совершенными.

*Есть возможность рассмотреть все изменения, которые были внесены в файлы. Чтобы выполнить данную операцию, нужно воспользоваться командой:*

**git diff**

*Учтите изменения в текстовом файле и произведите коммит:*

*git add test_resource.txt*<br>
*git commit -m "добавлено 'Hello, World!' в test_resource.txt"*

*Для просмотра всех коммитов используйте команду:*

*git log*

## Работа с ветками ##

Когда идет речь о работе с ветками и всеми связанными с ними процессами, становится понятным, что ограничиться работой в одной ветке одному человеку невозможно. Необходимо иметь возможность взаимодействия и сотрудничества с другими участниками команды. Именно поэтому существует ветвление.

Важно отметить, что как я уже упоминала изначально, **ветка в гите** — это всего лишь *подвижный указатель на коммиты*, т.е. на определенный момент в истории разработки проекта.

Позвольте рассмотреть некоторые аспекты работы в различных ветках: способы объединения изменений из одной ветки в другую, возможные конфликты, которые могут возникнуть, и прочие интересные моменты.

Но прежде чем приступить к этому, для того чтобы узнать полный список всех веток в конкретном репозитории и определить, на которой из них сейчас находишься, нужно ввести следующую команду:

*git branch -a*

**Создаем ветку на основе конкретного коммита**

Опираться будем на уникальный идентификатор коммита. Чтобы найти его, напишем:

*git log*

Видно, что у нас находится только одна ветка, называемая master, и звездочка перед ней указывает, что мы в данный момент находимся на этой ветке. Кстати, чтобы узнать, на какой ветке мы находимся, можно воспользоваться командой *git status*.

Существует несколько вариантов создания новых веток (могут быть и другие, но я рассмотрю эти два):
1. Создание новой ветки на основе текущей ветки, на которой мы находимся (этот случай встречается в 99% случаев).
2. Создание ветки на основе определенного коммита (это происходит в 1% случаев).

Давайте начнем с создания ветки на основе определенного коммита. Для этого мы будем использовать уникальный идентификатор коммита. Чтобы найти его, выполним команду:

*git log*

После того как мы найдем нужный коммит, выполним следующую команду:

git checkout -b development *идентификатор коммита*

В результате будет создана новая ветка, которая будет содержать только первые два коммита из ветки master. Чтобы проверить это, сначала убедимся, что мы перешли на новую ветку, а затем посмотрим количество коммитов:

*git status*<br>
*git log.*

**Теперь давайте снова проверим наши ветки, выполнив команду**:

*git branch -a*

Теперь рассмотрим *второй способ* создания ветки - создание ее на основе текущей ветки. Допустим, я хочу создать ветку на основе ветки *master*, поэтому сначала переключимся на нее, а затем создадим новую ветку. Вот как это делается:

*git checkout master* - переключаемся на ветку master;<br>
*git status* - проверяем, что мы находимся на ветке master.

Теперь видно, что мы переключились на ветку master, где уже работает файл .gitignore, и скомпилированный класс больше не отображается как непроиндексированный.

Теперь давайте создадим новую ветку на основе ветки master. Если у вас есть сомнения, будет ли эта ветка такой же, как и master, вы можете проверить это, выполните команду *git log* и просмотрите все коммиты.

## Слияние и конфликты ##

Теперь давайте поговорим о том, что такое конфликт и как его разрешить. Прежде чем разобраться в конфликте, нужно объяснить, что такое слияние (мердж) одной ветки в другую. 

Сначала есть основная ветка. Затем, на основе нее, создается второстепенная ветка, в которой вносятся изменения. Когда работа завершена, необходимо объединить (слить) одну ветку в другую.

После этого необходимо создать новый коммит для записи результатов слияния. Как результат, теперь в ветке master также есть этот коммит.

Давайте перейдем к работе с удаленными репозиториями. Последний шаг - разобраться с несколькими командами, которые используются для работы с удаленными репозиториями.

Существует множество удаленных репозиториев, и вот некоторые примеры:

- GitHub - это самое крупное хранилище репозиториев и совместной разработки. Я уже рассказывал о нем в предыдущих статьях.
Подпишитесь на мой аккаунт на GitHub. Я часто выкладываю свои наработки в сферах, которыми я занимаюсь во время работы.

- GitLab - это инструмент жизненного цикла DevOps с открытым исходным кодом, обеспечивающий управление репозиториями кода для Git, а также имеющий собственную вики, систему отслеживания ошибок и CI/CD пайплайн и т. д.
После новости о том, что Microsoft приобрела GitHub, некоторые разработчики дублировали свои наработки в GitLab.

- BitBucket - это сервис для хостинга проектов и совместной разработки, основанный на системе контроля версий Mercurial и Git. BitBucket имел преимущество перед GitHub тем, что предлагал бесплатные приватные репозитории. В прошлом году GitHub также предоставил эту возможность бесплатно.

*Первое, что нужно сделать при работе с удаленным репозиторием - склонировать проект в локальную копию.*

В результате у нас теперь есть полная копия проекта на локальном компьютере. Чтобы быть уверенным, что у нас находится последняя версия проекта, нужно добавить изменения из удаленного репозитория на локальный. Для этого выполним команду *git pull*.

Когда мы вносим изменения в удаленный репозиторий, локальный репозиторий будет обновлен после того, как мы извлечем изменения командой git pull.

Для отправки изменений на удаленный репозиторий сначала нужно создать новый коммит локально. 

Далее создадим коммит:

*git add name_file.extension*<br>
*git commit -m "prepated txt for pushing"*

И теперь отправим изменения на удаленный репозиторий командой *git push*.

## Цвяточек для того чтобы порадовать глаза ##

![цвяточек](flower.jpg "Цвяточек")